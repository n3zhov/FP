\documentclass[12pt]{article}

% Специальный шрифт, чтобы лучше читалось
\usepackage{libertine}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{titlesec}

\titleformat{\section}
  {\normalfont\Large\bfseries}{\thesection.}{0.3em}{}

\titleformat{\subsection}
  {\normalfont\large\bfseries}{\thesubsection.}{0.3em}{}

\titlespacing{\section}{0pt}{*2}{*2}
\titlespacing{\subsection}{0pt}{*1}{*1}
\titlespacing{\subsubsection}{0pt}{*0}{*0}
\usepackage{listings}
\lstloadlanguages{Lisp}
\lstset{extendedchars=false,
	breaklines=true,
	breakatwhitespace=true,
	keepspaces = true,
	tabsize=2
}
\begin{document}

\section*{Отчет по лабораторной работе № 1 \\
по курсу \guillemotleft Функциональное программирование\guillemotright}
\begin{flushright}
Студент группы М8О-307-19 МАИ \textit{Ежов Никита Павлович}, \textnumero 9 по списку \\
\makebox[7cm]{Контакты: {\tt nikita.ejov2012@yandex.ru} \hfill} \\
\makebox[7cm]{Работа выполнена: 30.03.2022 \hfill} \\
\ \\
Преподаватель: Иванов Дмитрий Анатольевич, доц. каф. 806 \\
\makebox[7cm]{Отчет сдан: \hfill} \\
\makebox[7cm]{Итоговая оценка: \hfill} \\
\makebox[7cm]{Подпись преподавателя: \hfill} \\

\end{flushright}

\section{Тема работы}
Примитивные функции и особые операторы Common Lisp.

\section{Цель работы}
Научиться вводить S-выражения в Lisp-систему, определять переменные и функции, работать с условными операторами, работать с числами, используя схему линейной и древовидной рекурсии.

\section{Задание (вариант № 1.29)}
Реализовать на языке Common Lisp программу для вычисления значения заданной функции с помощью линейно-рекурсивного процесса. Оценить требуемые время вычисления и оперативную память.
Функция $f$ задаётся правилом:
\begin{equation}
	f(n) = 
	 \begin{cases}
	   1 & $$n < 3$$\\
	   $$f(n) = f(n-1) \cdot (f(n-2)+2) \cdot (f(n-3)+3)$$ & $$n \geq 3$$
	 \end{cases}
\end{equation}

\section{Оборудование студента}
Процессор Intel i7-4770 (8) @ 3.9GHz, память: 16 Gb, разрядность системы: 64.

\section{Программное обеспечение}
ОС Kubuntu 20.04.4 LTS, комилятор GNU CLISP 2.49.92, текстовый редактор Atom 1.58.0

\pagebreak
\section{Идея, метод, алгоритм}
Рассмотрим случай, когда $n > 3$:

$$f(n) = f(n-1) \cdot (f(n-2)+2) \cdot (f(n-3)+3)$$.

Введём условные обозначения:
$$y1 = f(n-1)$$
$$y2 = f(n-2)$$
$$y3 = f(n-3)$$

Посчитаем значение $f(n)$. Т.к. первое $n$, для которого значение функции $\neq 1$ это $3$, распишем $f(3)$:

$$f(3) = f(2) \cdot (f(1)+2) \cdot (f(0)+3)$$

Теперь распишем то же самое для $f(4)$:

$$f(3) = f(3) \cdot (f(2)+2) \cdot (f(1)+3)$$

Как можно заметить, если мы идём снизу вверх, на шаге $n+1$ мы можем использовать аргументы и полученное значение из шага $n$, 
приравнивая переменные следующим образом:
$$y1 = (y1 \cdot (y2 + 2) \cdot (y3 + 3))$$
$$y2 = y1$$
$$y3 = y2$$

Таким образом, мы можем написать функцию, в которую на каждый шаг будем передавать обновленные значения $y1$ $y2$ $y3$, а в качестве результата ожидать
набор конечных $y$.
\\
Когда $n = arg$, останавливаем вычисление новых значений $y$ и передаём в качестве ответа для вычисления конечного результата в главной функции.
Почему не считать результат сразу в вспомогательной функции? Я хотел посмотреть, как работает multiple-value-binding.


Оценка сложности алгоритма: $O(n)$, т.к. используется линейная рекурсия.
\\
Оценка по памяти: $O(n)$, т.к. при новом рекурсивном вызове мы копируем константное кол-во аргументов $n$ кол-во раз.

\section{Сценарий выполнения работы}

\section{Распечатка программы и её результаты}

\subsection{Исходный код}
\lstinputlisting{./lab1.lisp}

\pagebreak
\subsection{Результаты работы}
\lstinputlisting{./log1.txt}

\pagebreak
\section{Дневник отладки}
\begin{tabular}{|p{50pt}|p{80pt}|p{140pt}|p{140pt}|}
\hline
Дата & Событие & Действие по исправлению & Примечание \\
\hline
\end{tabular}

\section{Замечания автора по существу работы}
На практике сначала казалось, что выполнить эту работу при помощи циклов было бы гораздо проще, но использование линейной рекурсии 
позволило "забыть" о таких вещах, как, например,  присвоение новых значений переменных после каждого шага.

\section{Выводы}
Я познакомился с синтаксисом языка Common Lisp. Было непривычно и сложно правильно расставить скобки, что и было основной трудностью.

Составленная программа работает за линейное время и использует линейное же количество памяти.

\end{document}